<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>index.js - Postman Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-docs-generator.html">docs-generator</a><ul class='methods'><li data-type='method'><a href="module-docs-generator.html#~generateDoc">generateDoc</a></li><li data-type='method'><a href="module-docs-generator.html#~generateIndex">generateIndex</a></li><li data-type='method'><a href="module-docs-generator.html#~pushIt">pushIt</a></li><li data-type='method'><a href="module-docs-generator.html#~readableStream">readableStream</a></li><li data-type='method'><a href="module-docs-generator.html#~repoName">repoName</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">index.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module docs-generator
 *
 * @todo pull in examples from d2-ui and host them
 */
const {
    generateFrom, publishTo, buildDir, sshPublicKeyPath, sshPrivateKeyPath
} = require('./config')
const { template } = require('./template')

const path = require('path')
const { StringDecoder } = require('string_decoder')
const { spawn } = require('child_process')
const fs = require('fs-extra')

const Rx = require('rxjs/Rx')
const Git = require('nodegit')

const allRepos = [].concat(generateFrom.apps, generateFrom.libs, generateFrom.utils)


/**
 * docsubject is the "global" subject which keeps track of if the
 * spawned child processes have completed or not.
 *
 * When they are all completed we can start to generate the index-page
 * of the documentation.
 */
const docsubject = new Rx.Subject()

docsubject
.scan((acc, curr) => acc.concat([curr]), [])
.subscribe(apps => {
        console.log(`[DOCGEN] Completed ${apps.length}/${allRepos.length}`)
        if (apps.length === allRepos.length) {
            console.log('[DOCGEN] All done, proceed to generate the index...')
            generateIndex(apps)
            copyFiles(path.join(__dirname, 'jekyll'))
            docsubject.complete()
        }
    },
    e => console.error('[DOCGEN] Problem generating Index', e),
    _ => pushIt(repoName(publishTo)) // when the subject completes, push the changes
)

function copyFiles(src) {
    try {
        fs.copySync(src, path.join(__dirname, buildDir, repoName(publishTo)), {
            errorOnExist: true
        })
    } catch (e) {
        throw new Error(e)
    }
}


/** 
 * Kick it. Uses the global subject in each spawned subprocess to
 * capture the completion of the subprocess so we do not start to
 * process the index generation until all subprocesses have completed.
 *
 * We want to first clone the `publishTo` repo to make sure it exists
 * before cloning all the `generateFrom` repos concurrently, which is
 * why we concat the repo$ on the target$.
 */
const repo$ = Rx.Observable
    .from(allRepos)
    .mergeMap(url => clone(url))
    .map(repo => generateDoc(repo, docsubject))

const target$ = clone(publishTo)
    .concat(repo$)
    .subscribe(
        e => console.log('[CLONE] Finished cloning', e),
        e => console.error('[CLONE] Error cloning', e)) //  katyperry mode
     


function clone(url) {
    const dir = path.join(__dirname, buildDir, repoName(url))
    const opts = {
        fetchOpts: {
            callbacks: {
                certificateCheck: () => 1,  // for macosx?
                credentials: (url, userName) => Git.Cred.sshKeyFromAgent(userName)
            }
        }
    }

    const repo = Git.Clone(url, dir, opts)
    console.log('[CLONE] Attempt repo', url, dir)
    return Rx.Observable.fromPromise(repo)
}




/** 
 * Generate the index of all docs by tricking jsdoc so we can reuse the
 * same theme. This function writes the actual file to disk and
 * completes the subject.
 *
 * @returns void
 */
function generateIndex(apps = []) {
    const index = path.join(__dirname, buildDir, repoName(publishTo), 'README.md')
    const dest = path.join(__dirname, buildDir, repoName(publishTo))

    const appList = apps
		.filter(a => generateFrom.apps.map(repoName).indexOf(a) !== -1)
		.map(app => `* [${app}](${app})`).join('\n')

    const libList = apps
		.filter(a => generateFrom.libs.map(repoName).indexOf(a) !== -1)
		.map(lib => `* [${lib}](${lib})`).join('\n')

    const utilList = apps
		.filter(a => generateFrom.utils.map(repoName).indexOf(a) !== -1)
		.map(util => `* [${util}](${util})`).join('\n')

	const t = template({
		body: {
			appList,
			libList,
			utilList
		}
	})

    try {
        fs.writeFileSync(index, t)

        console.log('[INDEX] The file has been saved!');

        const args = [
            '.',
            '--destination', dest,
            '--readme', index,
            '--template', './node_modules/postman-jsdoc-theme',
            '--verbose'
        ]

        const decoder = new StringDecoder('utf8') 
        const spawned = spawn('./node_modules/.bin/jsdoc', args, {stdio: 'pipe'})

        const indexDoc$ = Rx.Observable.merge(
            readableStream(spawned.stdin),
            //readableStream(spawned.stdout),
            readableStream(spawned.stderr)
        )
        .subscribe(
            x => console.log('[JSDOC:INDEX]', decoder.write(x)),
            x => console.error('[JSDOC:INDEX] failure:', x),
            _ => console.log('[JSDOC:INDEX] Complete.')
        )
    } catch (e) {
        throw new Error(e)
    }
}



/**
 * readableStream converts a Node-stream to an rx-observable
 */
function readableStream(stream) {
    const subject = new Rx.Subject()
    stream.on('data', data => subject.next(data))
    stream.on('error', error => subject.error(error))
    stream.on('end', _ => subject.complete())
    return subject
}





/**
 * Takes a Repository and generates documentation from it. This
 * functions writes to disk.
 *
 * @requires NodeGit
 * @requires JsDoc
 * @arg NodeGit.Repository
 * @returns string with name of repo
 */
function generateDoc (repo, subject) {
    const repoPath = repo.path().endsWith('.git/') ? repo.path().slice(0, -5) : repo.path()

    const decoder = new StringDecoder('utf8') 
	const name = repoName(repoPath)
    const docDestination = path.join(__dirname, buildDir, repoName(publishTo), name)

    const args = [
        path.join(repoPath, '.'),
        '--recurse',
        '--destination', docDestination,
        '--readme', path.join(repoPath, 'README.md'),
        '--template', './node_modules/postman-jsdoc-theme',
        '--verbose'
    ]

    console.log(`[JSDOC:${name}] cmd: `, args.join(' '))
        
    const spawned = spawn('./node_modules/.bin/jsdoc', args, { stdio: 'pipe' })

    const jsdoc$ = Rx.Observable.merge(
        readableStream(spawned.stdin),
        //readableStream(spawned.stdout),
        readableStream(spawned.stderr)
    )
    .subscribe(
        x => console.log(`[JSDOC:${name}]`, decoder.write(x)),
        x => console.error('[JSDOC] failure:', x),
        _ => subject.next(name)
    ) 
    return name
}





/**
 * gets the repo name from a given str
 *
 * @example git@github.com:foo/bar.git          => bar
 * @example git@github.com:fuz/buz/foo/bar.git  => bar
 * @example git@github.com:foo/bar.baz.buz.git  => bar.baz.buz
 * @example /path/to/repo/bar/.git/             => bar
 */
function repoName (str) {
    const s = str.endsWith('/') ? str.slice(0, -1) : str
    const r = s.endsWith('.git') ? s.slice(0, -4) : s
    const u = r.endsWith('/') ? r.slice(0, -1) : r
    const p = u.split('/').slice(-1).join()

    return p
}

const isDirectory = path => fs.statSync(path).isDirectory()
const getDirectories = pth =>
    fs
	.readdirSync(pth)
	.map(name => path.join(pth, name))
	.filter(e => !e.match(/\/\.git/))
	.filter(isDirectory)

const isFile = pth => fs.statSync(pth).isFile()  
const getFiles = pth =>
    fs.readdirSync(pth)
		.map(name => path.join(pth, name))
		.filter(isFile)

const getFilesRecursively = (pth) => {
    let dirs = getDirectories(pth)
    let files = dirs
        .map(dir => getFilesRecursively(dir))
        .reduce((a,b) => a.concat(b), [])
    return files.concat(getFiles(pth))
};


/**
 * By now we have built all the docs into a static bundle. Now we want
 * to modify the target repo and replace the content. Basically, wipe
 * the repo, add our new content, commit it, and push it to master.
 */
function pushIt(name) {
    const dir = path.join(__dirname, buildDir, name) 
    const files = getFilesRecursively(dir).map(str => str.replace(dir+'/',''))

    let repository
    let remote

    Rx.Observable.from(Git.Repository.open(dir))
    .mergeMap(function(repo) {
        repository = repo
		const sig = repo.defaultSignature()
        const msg = // whitespace inside template strings affect the commit msg, so align to left
`Update docs: ${new Date().toUTCString()}

List of apps used to generate docs:

${allRepos.join('\n')}
`
		return repo.createCommitOnHead(files, sig, sig, msg)
	})

    .mergeMap(function() {
        return repository.getRemote('origin')
    })

    .mergeMap(function(remoteResult) {
        remote = remoteResult;

        return remote.push(
            ["refs/heads/master:refs/heads/master"],
            {
                callbacks: {
                    certificateCheck: () => 1,
                    credentials: (url, userName) => Git.Cred.sshKeyFromAgent(userName)
                }
            }
        );
    })

    .subscribe(
        result => console.log('[Git] Success!'),
        reason  => console.log('[Git] FAIL', reason, repository),
        _ => console.log("[Git] Push to remote origin complete... Good bye.")
    )
}
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated at Thu Mar 15 2018 15:30:46 GMT+0000 (UTC)
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
